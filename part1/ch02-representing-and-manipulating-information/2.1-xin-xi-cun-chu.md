# 2.1 信息存储

大多数计算机使用 8 位的块，或者**字节**（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的**地址**（address），所有可能地址的集合就称为**虚拟地址空间**（virtual address space）。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现（见第 9 章）是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。 

在接下来的几章中，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的程序对象（program object），即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。例如，C 语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。C 编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管 C 编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

{% hint style="info" %}
### 给 C 语言初学者 - C 语言中指针的作用

指针是 C 语言的一个重要特性。它提供了引用数据结构（包括数组）的元素的机制。与变量类似，指针也有两个方面：值和类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。

真正理解指针需要查看它们在机器级上的表示以及实现。这将是第 3 章的重点之 一，3.10.1 节将对其进行深入介绍。
{% endhint %}

## 2.1.1 十六进制表示法
一个字节由8位组成。
在二进制表示法中，它的值域是 00000000~2~ ~ 11111111~2~
在十进制表示法中，它的值域是 0~10~ ~ 255~10~
在十六进制表示法中，它的值域是 00~16~ ~ FF~16~

| 进制与数据|  |  |  |  |  |  | | |
| :--- | :---: | :---: | :---: | :---: | :---: |  :---: | :---: | :---: |
| 十进制| 0 | 1 | 2 | 3 |4 | 5 | 6 | 7|
| 二进制 | 0000 | 0001 | 0010 | 0011 | 0100 | 0101| 0110| 0111 |
| 十六进制 | 0 | 1 | 2 | 3 | 4 | 5| 6 | 7|
| 十进制| 8 | 9 | 10 | 11 |12 | 13 | 14 | 15 |
| 二进制 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101| 1110| 1111 |
| 十六进制 | 8 | 9| A | B | C | D| E | F| 

> 一个简单的窍门是，记住十六进制数字A、C和F  相对应的十进制值。而对于把十六进制值B、D和E转换成十进制值时，则可以通过计算它们与前三个值的相对关系来完成。

## 2.1.2 字数据大小
每台计算机都有一个字长(word size),指明整数和指针数据的标称大小(nominal size)。对于一个字长为w位的机器而言，虚拟地址的范围为0~2^w-1^，程序最多访问2^w^个字节。
## 2.1.3 寻址和字节顺序

对于数据 0x01234567,使用大端法以及小端法表示：

大端法

| \*\*\*\* | 0x100 | 0x101 | 0x102 | 0x103 |  |
| :--- | :---: | :---: | :---: | :---: | :---: |
| ⋯ | 01 | 23 | 45 | 67 | ⋯ |

小端法

| \*\*\*\* | 0x100 | 0x101 | 0x102 | 0x103 |  |
| :--- | :---: | :---: | :---: | :---: | :---: |
| ⋯ | 67 | 45 | 23 | 01 | ⋯ |

## 2.1.4 表示字符串
c语言中字符串被编码为一个以NULL(其值为0)字符结尾的字符数组
## 2.1.5 表示代码

## 2.1.6 布尔代数简介
布尔代数运算
布尔运算~ NOT
| ~ | |
| :--- | :---: |
| 0 | 1 | 
| 1 | 0 | 
布尔运算 & AND
| & | 0| 1|
| :--- | :---: | :---: |
| 0 | 0 | 0 |
| 1 | 0 | 1 |

布尔运算 \| OR
| \| | 0| 1|
| :--- | :---: | :---: |
| 0 | 0 | 1 |
| 1 | 1 | 1 |
布尔运算 ^ XOR
| - | 0| 1|
| :--- | :---: | :---: |
| 0 | 0 | 1 |
| 1 | 1 | 0 |

位向量一个很有用的应用就是表示有限集合。我们可以用位向量[a~w-1~，…，a~1~，a~0~]编码任何子集A∈{0，1，…，w-1}，其中a~i~=1当且仅当i∈A。例如，（记住我们是把a~i~写在左边，而将a~0~写在右边），位向量a=[0110100]表示集合A={0,3,5,6}，而b=[01010101]表示集合B={0,2,4,6}。使用这种编码集合的方法，布尔运算|和&分别对应于集合的并和交，而~对应于于集合的补。还是用前面那个例子，运算a&b得到位向量[01000001]，而A∩B={0,6}。
## 2.1.7 C 语言中的位级运算
或就是 |
与就是 &
取反就是 ~
异或就是 ^

## 2.1.8 C 语言中的逻辑运算
逻辑运算符区别于位级运算
|| 表示逻辑 OR
&& 表示逻辑 AND
！ 表示逻辑  NOT
## 2.1.9 C 语言中的移位运算
逻辑右移 高位补0
算术右移 高位补最高有效位


